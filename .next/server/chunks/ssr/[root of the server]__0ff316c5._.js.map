{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["\nimport {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\nimport { config } from 'dotenv';\n\nconfig(); // Ensures .env variables are loaded\n\nconst plugins = [];\nlet apiKeyFound = false;\nlet apiKeyEnvVarName = '';\n\n// Prioritize GEMINI_API_KEY, then GOOGLE_API_KEY\nconst geminiApiKey = process.env.GEMINI_API_KEY;\nconst googleApiKey = process.env.GOOGLE_API_KEY; // Kept for backward compatibility or alternative naming\n\nlet apiKeyToUse: string | undefined = undefined;\n\nif (geminiApiKey && geminiApiKey.trim() !== \"\") {\n  apiKeyToUse = geminiApiKey;\n  apiKeyEnvVarName = 'GEMINI_API_KEY';\n  apiKeyFound = true;\n  console.log(`Genkit: Found GEMINI_API_KEY.`);\n} else if (googleApiKey && googleApiKey.trim() !== \"\") {\n  apiKeyToUse = googleApiKey;\n  apiKeyEnvVarName = 'GOOGLE_API_KEY';\n  apiKeyFound = true;\n  console.log(`Genkit: GEMINI_API_KEY not found or empty, using GOOGLE_API_KEY.`);\n}\n\nif (apiKeyFound && apiKeyToUse) {\n  plugins.push(googleAI({ apiKey: apiKeyToUse }));\n  console.log(`Genkit: Initializing Google AI plugin using ${apiKeyEnvVarName}.`);\n} else {\n  console.warn(\n    '⚠️ Genkit Initialization Warning: Neither GEMINI_API_KEY nor GOOGLE_API_KEY is set or is empty in the environment variables.\\n' +\n    '   AI-powered features will use fallbacks or may not be fully functional.\\n' +\n    '   If you intend to use Google AI, please ensure GEMINI_API_KEY (or GOOGLE_API_KEY) is set in your .env file.\\n' +\n    '   You can obtain an API key from Google AI Studio (https://aistudio.google.com/app/apikey).'\n  );\n}\n\nexport const ai = genkit({\n  plugins: plugins,\n  // Removed logLevel: 'debug' as it's not a valid option for genkit() in v1.x\n  // For verbose logging, Genkit CLI might have flags, or you can use console.log within flows.\n});\n\nconst googleAiPluginAdded = plugins.some(p => p.name === 'google-ai');\n\nif (googleAiPluginAdded) {\n  console.log(\"Genkit: Google AI plugin initialized successfully. Prompts are configured to use 'googleai/gemini-pro' by default in flows unless overridden.\");\n} else {\n    console.warn(\n        '⚠️ Genkit initialized without the Google AI plugin (likely due to missing GEMINI_API_KEY or GOOGLE_API_KEY). ' +\n        'AI-dependent flows will use fallbacks or may not function as expected.'\n    );\n}\n"],"names":[],"mappings":";;;AACA;AAAA;AACA;AAAA;AACA;;;;AAEA,CAAA,GAAA,qIAAA,CAAA,SAAM,AAAD,KAAK,oCAAoC;AAE9C,MAAM,UAAU,EAAE;AAClB,IAAI,cAAc;AAClB,IAAI,mBAAmB;AAEvB,iDAAiD;AACjD,MAAM,eAAe,QAAQ,GAAG,CAAC,cAAc;AAC/C,MAAM,eAAe,QAAQ,GAAG,CAAC,cAAc,EAAE,wDAAwD;AAEzG,IAAI,cAAkC;AAEtC,IAAI,gBAAgB,aAAa,IAAI,OAAO,IAAI;IAC9C,cAAc;IACd,mBAAmB;IACnB,cAAc;IACd,QAAQ,GAAG,CAAC,CAAC,6BAA6B,CAAC;AAC7C,OAAO,IAAI,gBAAgB,aAAa,IAAI,OAAO,IAAI;IACrD,cAAc;IACd,mBAAmB;IACnB,cAAc;IACd,QAAQ,GAAG,CAAC,CAAC,gEAAgE,CAAC;AAChF;AAEA,IAAI,eAAe,aAAa;IAC9B,QAAQ,IAAI,CAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD,EAAE;QAAE,QAAQ;IAAY;IAC5C,QAAQ,GAAG,CAAC,CAAC,4CAA4C,EAAE,iBAAiB,CAAC,CAAC;AAChF,OAAO;IACL,QAAQ,IAAI,CACV,mIACA,gFACA,oHACA;AAEJ;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;AAGX;AAEA,MAAM,sBAAsB,QAAQ,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK;AAEzD,IAAI,qBAAqB;IACvB,QAAQ,GAAG,CAAC;AACd,OAAO;IACH,QAAQ,IAAI,CACR,kHACA;AAER","debugId":null}},
    {"offset": {"line": 268, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/enhance-medicine-search.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview Enhances medicine search functionality by extracting the intended medicine name from potentially misspelled, partial queries, barcodes, or composition keywords.\n *\n * - enhanceMedicineSearch - A function that takes a user's search query and returns a term suitable for backend search.\n * - EnhanceMedicineSearchInput - The input type for the enhanceMedicineSearch function.\n * - EnhanceMedicineSearchOutput - The return type for the enhanceMedicineSearch function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst EnhanceMedicineSearchInputSchema = z.object({\n  query: z.string().describe('The user input query, which may contain misspellings, be incomplete, a barcode, or composition keywords, potentially including dosages.'),\n});\nexport type EnhanceMedicineSearchInput = z.infer<typeof EnhanceMedicineSearchInputSchema>;\n\nconst EnhanceMedicineSearchOutputSchema = z.object({\n  correctedMedicineName: z\n    .string()\n    .describe('The corrected/completed medicine name, barcode, or composition keyword extracted from the query, suitable for backend search. Should retain specific details like dosages if they appear to be part of a product name.'),\n  source: z.enum(['ai_enhanced', 'ai_unavailable', 'ai_failed', 'original_query_used']).optional().describe(\"Indicates the source or status of the correctedMedicineName. 'ai_enhanced' if AI successfully processed. 'ai_unavailable' if AI couldn't be used (e.g. no API key). 'ai_failed' if AI processing failed. 'original_query_used' if AI was skipped or failed and original query is returned.\"),\n});\nexport type EnhanceMedicineSearchOutput = z.infer<typeof EnhanceMedicineSearchOutputSchema>;\n\nexport async function enhanceMedicineSearch(input: EnhanceMedicineSearchInput): Promise<EnhanceMedicineSearchOutput> {\n  if (!input || typeof input.query !== 'string' || input.query.trim() === '') {\n    console.warn(`enhanceMedicineSearch: Invalid or empty input query. Input: ${JSON.stringify(input)}`);\n    return {\n      correctedMedicineName: input?.query || \"\", \n      source: 'original_query_used', // Treat as if AI was skipped for empty/invalid query\n    };\n  }\n\n  try {\n    const result = await enhanceMedicineSearchFlow(input);\n    console.log(\"enhanceMedicineSearch (wrapper) - Flow Result:\", JSON.stringify(result, null, 2));\n    if (result.source === 'ai_unavailable') {\n        console.warn(`enhanceMedicineSearch: Flow indicated AI is unavailable. Query: \"${input.query}\"`);\n    }\n    // Ensure correctedMedicineName is not empty; if AI returns empty, fallback to original.\n    if (!result.correctedMedicineName || result.correctedMedicineName.trim() === '') {\n        console.warn(`enhanceMedicineSearch: AI returned empty correctedMedicineName. Falling back to original query. Input: \"${input.query}\", AI Result: ${JSON.stringify(result)}`);\n        return { correctedMedicineName: input.query, source: 'original_query_used' };\n    }\n    return result;\n  } catch (error: unknown) {\n    let message = \"Unknown error during AI search enhancement.\";\n    if (error instanceof Error) {\n      message = error.message;\n    } else if (typeof error === 'string') {\n      message = error;\n    }\n    console.error(`Error in enhanceMedicineSearch wrapper for query \"${input.query}\":`, message, error);\n    return { correctedMedicineName: input.query, source: 'ai_failed' };\n  }\n}\n\nconst enhanceMedicineSearchPrompt = ai.definePrompt({\n  name: 'enhanceMedicineSearchPrompt',\n  model: 'googleai/gemini-pro', // Explicitly use gemini-pro\n  input: {schema: EnhanceMedicineSearchInputSchema},\n  output: {schema: EnhanceMedicineSearchOutputSchema},\n  prompt: `You are an AI assistant for a medicine search application. Your primary goal is to help identify the medicine the user is looking for.\nThe user query can be a medicine name (possibly misspelled or partial, and may include dosages like \"500mg\"), its barcode, or keywords from its composition.\nBased on the input, determine the most likely *medicine name* or the *original query if it seems to be a direct identifier like a barcode or a specific product formulation that doesn't map to a more general common name*.\nReturn this as \\`correctedMedicineName\\`.\nSet the 'source' field to 'ai_enhanced'.\n\nThe subsequent search will use this \\`correctedMedicineName\\` to look up medicines by name, barcode, or composition.\nIf the query includes dosage or strength (e.g., \"Paracetamol 500mg\", \"Dolo 650\"), and this appears to be part of a specific product name or common way of referring to it, RETAIN these details in \\`correctedMedicineName\\`.\nIf the query is a general description (e.g., \"medicine for headache\"), extract the key medicinal component.\n\nExamples:\n- Query: \"panadol\", correctedMedicineName: \"Panadol\", source: \"ai_enhanced\"\n- Query: \"amoxilin\", correctedMedicineName: \"Amoxicillin\", source: \"ai_enhanced\"\n- Query: \"dolo 650\", correctedMedicineName: \"Dolo 650\", source: \"ai_enhanced\"\n- Query: \"Paracetamol 500mg Tablet\", correctedMedicineName: \"Paracetamol 500mg Tablet\", source: \"ai_enhanced\"\n- Query: \"Aceclofenac 100 mg Paracetamol 325 mg\", correctedMedicineName: \"Aceclofenac 100 mg Paracetamol 325 mg\", source: \"ai_enhanced\"\n- Query: \"Barcode 1234567890123 for Paracetamol\", correctedMedicineName: \"Paracetamol\", source: \"ai_enhanced\"\n- Query: \"1234567890123\" (assume this is a barcode), correctedMedicineName: \"1234567890123\", source: \"ai_enhanced\"\n- Query: \"syrup with paracetamol 500mg\" (descriptive), correctedMedicineName: \"Paracetamol\", source: \"ai_enhanced\"\n- Query: \"medicine for headache with ibuprofen\", correctedMedicineName: \"Ibuprofen\", source: \"ai_enhanced\"\n\nIf the input is a barcode, and you cannot confidently map it to a common medicine name, return the barcode itself.\nIf the input is a composition keyword (e.g. \"Paracetamol\"), return it or a slightly refined version.\nThe key is to provide a search term that will be effective for the backend, preserving specificity when it seems intentional.\nAlways set 'source' to 'ai_enhanced' in your direct response. Do not return empty strings for correctedMedicineName; if unsure, return the original query.\n\nUser Query: {{{query}}}\n  `,\n});\n\nconst enhanceMedicineSearchFlow = ai.defineFlow(\n  {\n    name: 'enhanceMedicineSearchFlow',\n    inputSchema: EnhanceMedicineSearchInputSchema,\n    outputSchema: EnhanceMedicineSearchOutputSchema,\n  },\n  async (input: EnhanceMedicineSearchInput): Promise<EnhanceMedicineSearchOutput> => {\n    let rawOutputFromAI: EnhanceMedicineSearchOutput | null = null;\n    try {\n      const {output} = await enhanceMedicineSearchPrompt(input);\n      rawOutputFromAI = output;\n      console.log(\"enhanceMedicineSearchFlow - Raw AI Output:\", JSON.stringify(rawOutputFromAI, null, 2));\n\n      if (!rawOutputFromAI ||\n          typeof rawOutputFromAI.correctedMedicineName !== 'string' ||\n          rawOutputFromAI.correctedMedicineName.trim() === '' || // Ensure not empty\n          (rawOutputFromAI.source && !['ai_enhanced', 'ai_unavailable', 'ai_failed', 'original_query_used'].includes(rawOutputFromAI.source)) // Validate source if present\n        ) {\n        console.warn(\n            \"enhanceMedicineSearchFlow: AI returned invalid structure, empty correctedMedicineName, or invalid source. Input:\",\n            JSON.stringify(input, null, 2),\n            \"Raw Output:\",\n            JSON.stringify(rawOutputFromAI, null, 2)\n        );\n        return { correctedMedicineName: input.query, source: 'original_query_used' };\n      }\n      // The prompt asks AI to set source to 'ai_enhanced'. If it's something else, it implies an issue on AI's side or schema mismatch.\n      // However, the schema for EnhanceMedicineSearchOutputSchema has source as optional.\n      // If AI provides a valid correctedMedicineName but no source, we'll assume 'ai_enhanced' based on prompt instructions.\n      return { \n        correctedMedicineName: rawOutputFromAI.correctedMedicineName,\n        source: rawOutputFromAI.source || 'ai_enhanced' \n      };\n\n    } catch (flowError: unknown) {\n      let errorMessage = \"AI model failed to process search enhancement or an unexpected error occurred.\";\n      let errorStack: string | undefined;\n\n      if (flowError instanceof Error) {\n          errorMessage = flowError.message;\n          errorStack = flowError.stack;\n\n          if (errorMessage.includes('API key not valid') || errorMessage.includes('User location is not supported') || errorMessage.includes('API_KEY_INVALID') || errorMessage.includes('API key is invalid')) {\n            console.error(`enhanceMedicineSearchFlow: Probable API key or configuration issue: ${errorMessage}`);\n            return { correctedMedicineName: input.query, source: 'ai_unavailable' };\n          }\n          if (errorMessage.includes('model not found') || errorMessage.includes('Could not find model')) {\n            console.error(`enhanceMedicineSearchFlow: AI model not found or configured: ${errorMessage}`);\n            return { correctedMedicineName: input.query, source: 'ai_unavailable' };\n          }\n          if (errorMessage.includes('Billing account not found') || errorMessage.includes('billing issues')) {\n            console.error(`enhanceMedicineSearchFlow: Billing issue: ${errorMessage}`);\n            return { correctedMedicineName: input.query, source: 'ai_unavailable' };\n          }\n      } else if (typeof flowError === 'string') {\n          errorMessage = flowError;\n      } else if (flowError && typeof flowError === 'object' && 'message' in flowError) {\n          errorMessage = String((flowError as any).message);\n      }\n\n      console.error(`enhanceMedicineSearchFlow: Error for input ${JSON.stringify(input)} - Message: ${errorMessage}${errorStack ? `\\nStack: ${errorStack}` : ''}\\nRaw AI Output (if available): ${JSON.stringify(rawOutputFromAI, null, 2)}\\nOriginal Error Object:`, flowError);\n      return { correctedMedicineName: input.query, source: 'ai_failed' };\n    }\n  }\n);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 454, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 505, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/medisearch-app.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/components/medisearch-app.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/medisearch-app.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAqS,GAClU,mEACA","debugId":null}},
    {"offset": {"line": 519, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/medisearch-app.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/components/medisearch-app.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/medisearch-app.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAiR,GAC9S,+CACA","debugId":null}},
    {"offset": {"line": 533, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 543, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx"],"sourcesContent":["import MediSearchApp from \"@/components/medisearch-app\";\n\nexport default function HomePage() {\n  return <MediSearchApp />;\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAEe,SAAS;IACtB,qBAAO,8OAAC,uIAAA,CAAA,UAAa;;;;;AACvB","debugId":null}}]
}